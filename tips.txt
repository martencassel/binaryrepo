/*
	https://medium.com/@matryer/how-i-write-go-http-services-after-seven-years-37c208122831

	server.go

	Define a server type
	Make server an http.Handler (implement ServeHTTP method)

	func (s *server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
		s.router.ServeHTTP(w, r)
	}

	routes.go

	func (s *server) routes() {
		s.router.Get("/api", s.handleAPI())
		s.router.Get("/about", s.handleAbout())
		s.router.Get("/contact", s.handleContact())
	}

	Handlers hang off the server. Methods on the server, gives them access to dependencies.
	Other handlers have access to s too, so be careful.

	func (s *server) handleSomething() http.HandlerFunc {
		// put some programming here
	}

	Naming handler methods:
	handleTasksCreate, handleTasksDone, handleTasksGet
	handleAuthLogin, handleAuthLogout

	Return the handler (Allows for handler specific setup)

	func (s *server) handleSomething() http.HandlerFunc {
		things := prepareThing()
		return func(w http.ResponseWriter, r *http.Request) {
			// use thing
		}
	}

	Take arguments for handler-specific dependencies. Format variable is accesible to the handlers.
		handleRandomQuote(q Quoter, r *rand.Rand) http.HandlerFunc

	Too big ? Have many servers.

	// people.go
		type serverPeople struct {
			db *sql.DB
		}
	// comments.go
		type serverComments struct {
			db *sql.DB
		}

	HandlerFunc over Handler

	Middleware are just go functions

*/
